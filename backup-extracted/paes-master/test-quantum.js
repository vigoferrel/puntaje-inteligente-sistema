#!/usr/bin/env node

/**
 * üß™ PAES MASTER QUANTUM TESTING SCRIPT
 * Script para probar el sistema cu√°ntico en segundo plano
 */

import QuantumEngine from './quantum-core/quantum-engine.js';
import PAESStructureManager from './quantum-core/paes-structure.js';

class QuantumTester {
  constructor() {
    this.quantumEngine = new QuantumEngine();
    this.paesManager = new PAESStructureManager();
    this.testResults = [];
  }

  async runAllTests() {
    console.log('üß™ INICIANDO TESTING COMPLETO DE PAES MASTER QUANTUM');
    console.log('=' .repeat(60));
    
    try {
      // Test 1: Inicializaci√≥n del motor cu√°ntico
      await this.testQuantumEngineInitialization();
      
      // Test 2: Estructura oficial PAES
      await this.testPAESStructure();
      
      // Test 3: Taxonom√≠a Bloom
      await this.testBloomTaxonomy();
      
      // Test 4: Nodos de aprendizaje
      await this.testLearningNodes();
      
      // Test 5: Sesiones de estudio
      await this.testStudySessions();
      
      // Test 6: Spotify Neural
      await this.testSpotifyNeural();
      
      // Test 7: Progreso y anal√≠ticas
      await this.testProgressAndAnalytics();
      
      // Test 8: Recomendaciones
      await this.testRecommendations();
      
      // Mostrar resultados finales
      this.showTestResults();
      
    } catch (error) {
      console.error('‚ùå Error en testing:', error);
    }
  }

  async testQuantumEngineInitialization() {
    console.log('\nüåå Test 1: Inicializaci√≥n del Motor Cu√°ntico');
    
    try {
      await this.quantumEngine.initialize();
      
      const state = this.quantumEngine.quantumState;
      const isValid = state.nodes.size > 0 && 
                     state.bloom.size > 0 && 
                     state.spotify.quantumPlaylists.length > 0;
      
      this.addTestResult('Quantum Engine Initialization', isValid, {
        nodes: state.nodes.size,
        bloom: state.bloom.size,
        spotify: state.spotify.quantumPlaylists.length,
        entanglement: state.entanglement.size
      });
      
      console.log('‚úÖ Motor cu√°ntico inicializado correctamente');
      
    } catch (error) {
      this.addTestResult('Quantum Engine Initialization', false, { error: error.message });
      console.error('‚ùå Error inicializando motor cu√°ntico:', error);
    }
  }

  async testPAESStructure() {
    console.log('\nüìö Test 2: Estructura Oficial PAES');
    
    try {
      const structure = this.paesManager.getStructure();
      
      // Verificar estructura Matem√°ticas 1 y 2
      const hasMatematicaM1 = structure.MATEMATICA_M1 && 
                             structure.MATEMATICA_M1.skills.includes('N√∫meros') &&
                             structure.MATEMATICA_M1.skills.includes('√Ålgebra');
      
      const hasMatematicaM2 = structure.MATEMATICA_M2 && 
                             structure.MATEMATICA_M2.skills.includes('Probabilidad') &&
                             structure.MATEMATICA_M2.skills.includes('Estad√≠stica');
      
      const hasCompetenciaLectora = structure.COMPETENCIA_LECTORA &&
                                   structure.COMPETENCIA_LECTORA.skills.includes('Localizar');
      
      const isValid = hasMatematicaM1 && hasMatematicaM2 && hasCompetenciaLectora;
      
      this.addTestResult('PAES Structure', isValid, {
        matematicaM1: hasMatematicaM1,
        matematicaM2: hasMatematicaM2,
        competenciaLectora: hasCompetenciaLectora,
        totalTestTypes: Object.keys(structure).length
      });
      
      console.log('‚úÖ Estructura oficial PAES validada');
      
    } catch (error) {
      this.addTestResult('PAES Structure', false, { error: error.message });
      console.error('‚ùå Error validando estructura PAES:', error);
    }
  }

  async testBloomTaxonomy() {
    console.log('\nüå∏ Test 3: Taxonom√≠a Bloom');
    
    try {
      const bloom = this.paesManager.bloom;
      const hasAllLevels = bloom.L1 && bloom.L2 && bloom.L3 && 
                          bloom.L4 && bloom.L5 && bloom.L6;
      
      // Verificar mapeo Bloom por sub-habilidades
      const testMapping = this.paesManager.getBloomLevel('MATEMATICA_M1', 'Enteros');
      const hasValidMapping = testMapping && testMapping.startsWith('L');
      
      const isValid = hasAllLevels && hasValidMapping;
      
      this.addTestResult('Bloom Taxonomy', isValid, {
        hasAllLevels,
        hasValidMapping,
        testMapping,
        totalLevels: Object.keys(bloom).length
      });
      
      console.log('‚úÖ Taxonom√≠a Bloom validada');
      
    } catch (error) {
      this.addTestResult('Bloom Taxonomy', false, { error: error.message });
      console.error('‚ùå Error validando taxonom√≠a Bloom:', error);
    }
  }

  async testLearningNodes() {
    console.log('\nüåü Test 4: Nodos de Aprendizaje');
    
    try {
      // Crear nodo de testing
      const testNode = this.paesManager.createLearningNode(
        'MATEMATICA_M1',
        'N√∫meros',
        'Enteros'
      );
      
      const hasValidStructure = testNode.id && 
                               testNode.testType === 'MATEMATICA_M1' &&
                               testNode.skill === 'N√∫meros' &&
                               testNode.subSkill === 'Enteros' &&
                               testNode.bloomLevel;
      
      // Verificar nodo en motor cu√°ntico
      const quantumNode = this.quantumEngine.createQuantumNode(
        testNode.id,
        'content',
        testNode
      );
      
      const isInQuantumState = this.quantumEngine.quantumState.nodes.has(testNode.id);
      
      const isValid = hasValidStructure && isInQuantumState;
      
      this.addTestResult('Learning Nodes', isValid, {
        hasValidStructure,
        isInQuantumState,
        nodeId: testNode.id,
        bloomLevel: testNode.bloomLevel,
        difficulty: testNode.difficulty
      });
      
      console.log('‚úÖ Nodos de aprendizaje validados');
      
    } catch (error) {
      this.addTestResult('Learning Nodes', false, { error: error.message });
      console.error('‚ùå Error validando nodos de aprendizaje:', error);
    }
  }

  async testStudySessions() {
    console.log('\nüéØ Test 5: Sesiones de Estudio');
    
    try {
      const testUserId = 'test-user-session';
      const sessionData = {
        testType: 'MATEMATICA_M1',
        skill: '√Ålgebra',
        subSkill: 'B√°sica',
        duration: 45,
        difficulty: 'intermedio',
        bloomLevel: 'L2'
      };
      
      const result = await this.quantumEngine.processQuantumNeural(
        testUserId,
        'study_session',
        sessionData
      );
      
      const hasValidResult = result && 
                            result.success && 
                            result.bloomProgress !== undefined &&
                            result.spotifyTrack !== undefined;
      
      this.addTestResult('Study Sessions', hasValidResult, {
        hasValidResult,
        bloomProgress: result?.bloomProgress,
        bloomLevel: result?.bloomLevel,
        spotifyTrack: result?.spotifyTrack ? 'Sincronizado' : 'No sincronizado'
      });
      
      console.log('‚úÖ Sesiones de estudio validadas');
      
    } catch (error) {
      this.addTestResult('Study Sessions', false, { error: error.message });
      console.error('‚ùå Error validando sesiones de estudio:', error);
    }
  }

  async testSpotifyNeural() {
    console.log('\nüéµ Test 6: Spotify Neural');
    
    try {
      const playlists = this.quantumEngine.quantumState.spotify.quantumPlaylists;
      
      // Verificar playlist de Matem√°tica M1
      const matematicaM1Playlist = playlists.find(p => 
        p.testType === 'MATEMATICA_M1' && p.skill === 'N√∫meros'
      );
      
      const hasValidPlaylist = matematicaM1Playlist && 
                              matematicaM1Playlist.tracks.length > 0;
      
      // Verificar track espec√≠fico
      const hasValidTrack = matematicaM1Playlist?.tracks.some(t => 
        t.subSkill === 'Enteros' && t.bloom === 'L1'
      );
      
      const isValid = hasValidPlaylist && hasValidTrack;
      
      this.addTestResult('Spotify Neural', isValid, {
        hasValidPlaylist,
        hasValidTrack,
        totalPlaylists: playlists.length,
        totalTracks: playlists.reduce((sum, p) => sum + p.tracks.length, 0)
      });
      
      console.log('‚úÖ Spotify Neural validado');
      
    } catch (error) {
      this.addTestResult('Spotify Neural', false, { error: error.message });
      console.error('‚ùå Error validando Spotify Neural:', error);
    }
  }

  async testProgressAndAnalytics() {
    console.log('\nüìä Test 7: Progreso y Anal√≠ticas');
    
    try {
      const testUserId = 'test-user-analytics';
      
      // Crear progreso de testing
      const progress = this.quantumEngine.getUserProgressByStructure(testUserId);
      
      const hasValidProgress = progress && 
                              typeof progress === 'object' &&
                              Object.keys(progress).length > 0;
      
      // Verificar medici√≥n cu√°ntica
      const measurement = await this.quantumEngine.processQuantumNeural(
        testUserId,
        'quantum_measurement',
        { measurementType: 'paes_structure' }
      );
      
      const hasValidMeasurement = measurement && 
                                 measurement.measurementType === 'paes_structure' &&
                                 measurement.quantumState;
      
      const isValid = hasValidProgress && hasValidMeasurement;
      
      this.addTestResult('Progress and Analytics', isValid, {
        hasValidProgress,
        hasValidMeasurement,
        progressKeys: Object.keys(progress || {}),
        quantumCoherence: measurement?.quantumState?.coherence
      });
      
      console.log('‚úÖ Progreso y anal√≠ticas validadas');
      
    } catch (error) {
      this.addTestResult('Progress and Analytics', false, { error: error.message });
      console.error('‚ùå Error validando progreso y anal√≠ticas:', error);
    }
  }

  async testRecommendations() {
    console.log('\nüéØ Test 8: Recomendaciones');
    
    try {
      const testUserId = 'test-user-recommendations';
      
      // Simular progreso para generar recomendaciones
      await this.quantumEngine.processQuantumNeural(testUserId, 'study_session', {
        testType: 'MATEMATICA_M1',
        skill: 'N√∫meros',
        subSkill: 'Enteros',
        duration: 30,
        score: 75
      });
      
      // Obtener recomendaciones
      const recommendations = this.quantumEngine.getUserProgressByStructure(testUserId);
      
      const hasValidRecommendations = recommendations && 
                                    Object.keys(recommendations).length > 0;
      
      const isValid = hasValidRecommendations;
      
      this.addTestResult('Recommendations', isValid, {
        hasValidRecommendations,
        recommendationTypes: Object.keys(recommendations || {}),
        totalRecommendations: Object.keys(recommendations || {}).length
      });
      
      console.log('‚úÖ Recomendaciones validadas');
      
    } catch (error) {
      this.addTestResult('Recommendations', false, { error: error.message });
      console.error('‚ùå Error validando recomendaciones:', error);
    }
  }

  addTestResult(testName, passed, details) {
    this.testResults.push({
      test: testName,
      passed,
      details,
      timestamp: new Date().toISOString()
    });
  }

  showTestResults() {
    console.log('\n' + '=' .repeat(60));
    console.log('üìä RESULTADOS DEL TESTING COMPLETO');
    console.log('=' .repeat(60));
    
    const passedTests = this.testResults.filter(r => r.passed).length;
    const totalTests = this.testResults.length;
    const successRate = ((passedTests / totalTests) * 100).toFixed(1);
    
    console.log(`\n‚úÖ Tests pasados: ${passedTests}/${totalTests} (${successRate}%)`);
    
    for (const result of this.testResults) {
      const status = result.passed ? '‚úÖ' : '‚ùå';
      console.log(`${status} ${result.test}`);
      
      if (result.details && Object.keys(result.details).length > 0) {
        console.log(`   üìã ${JSON.stringify(result.details, null, 2)}`);
      }
    }
    
    console.log('\n' + '=' .repeat(60));
    
    if (passedTests === totalTests) {
      console.log('üéâ ¬°TODOS LOS TESTS PASARON! PAES MASTER QUANTUM EST√Å LISTO');
    } else {
      console.log('‚ö†Ô∏è  Algunos tests fallaron. Revisar implementaci√≥n.');
    }
    
    console.log('=' .repeat(60));
  }
}

// Ejecutar testing si se ejecuta directamente
if (import.meta.url === `file://${process.argv[1]}`) {
  const tester = new QuantumTester();
  tester.runAllTests().catch(console.error);
}

export default QuantumTester;
