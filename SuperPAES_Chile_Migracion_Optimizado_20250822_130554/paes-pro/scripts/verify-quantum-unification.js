#!/usr/bin/env node
/**
 * Script de verificaci√≥n de la unificaci√≥n completa del sistema cu√°ntico
 * Verifica que todos los usos de Math.random() han sido reemplazados
 * y que el sistema cu√°ntico est√° correctamente implementado
 */

const fs = require('fs');
const path = require('path');

const PROJECT_ROOT = path.resolve(__dirname, '..');

// Configuraci√≥n de archivos y directorios a verificar
const CONFIG = {
  // Directorios a incluir en la b√∫squeda
  includeDirs: [
    'app',
    'lib',
    'components',
    'pages',
    'src',
    'fuentes/bloom-skill-flow-main/src'
  ],
  
  // Extensiones de archivos a verificar
  fileExtensions: ['.ts', '.tsx', '.js', '.jsx'],
  
  // Directorios a excluir
  excludeDirs: [
    'node_modules',
    '.next',
    'dist',
    'build',
    '.git',
    'reading-competence-app/dist' // C√≥digo compilado externo
  ],
  
  // Archivos espec√≠ficos a excluir (c√≥digo compilado/bibliotecas externas)
  excludeFiles: [
    'dashboard.aa786e0d.js' // C√≥digo compilado de bibliotecas externas
  ]
};

class QuantumUnificationVerifier {
  constructor() {
    this.results = {
      totalFiles: 0,
      verifiedFiles: 0,
      mathRandomUsages: [],
      quantumImplementations: [],
      issues: [],
      summary: {}
    };
  }

  /**
   * Ejecuta la verificaci√≥n completa
   */
  async verify() {
    console.log('üîç Iniciando verificaci√≥n de unificaci√≥n del sistema cu√°ntico...\n');
    
    try {
      // Verificar estructura del proyecto
      await this.verifyProjectStructure();
      
      // Buscar usos restantes de Math.random()
      await this.scanForMathRandom();
      
      // Verificar implementaciones del sistema cu√°ntico
      await this.verifyQuantumImplementations();
      
      // Verificar configuraci√≥n y endpoints
      await this.verifySystemConfiguration();
      
      // Generar reporte
      this.generateReport();
      
    } catch (error) {
      console.error('‚ùå Error durante la verificaci√≥n:', error);
      process.exit(1);
    }
  }

  /**
   * Verifica la estructura b√°sica del proyecto
   */
  async verifyProjectStructure() {
    console.log('üìÅ Verificando estructura del proyecto...');
    
    const requiredFiles = [
      'lib/utils/quantumRandom.ts',
      'app/api/quantum-status/route.ts',
      'lib/services/examGeneratorService.ts'
    ];
    
    for (const file of requiredFiles) {
      const filePath = path.join(PROJECT_ROOT, file);
      if (!fs.existsSync(filePath)) {
        this.results.issues.push({
          type: 'missing_file',
          file: file,
          message: 'Archivo requerido del sistema cu√°ntico no encontrado'
        });
      } else {
        console.log(`  ‚úÖ ${file}`);
      }
    }
  }

  /**
   * Busca usos restantes de Math.random() en el c√≥digo fuente
   */
  async scanForMathRandom() {
    console.log('\nüîé Buscando usos restantes de Math.random()...');
    
    const files = this.getSourceFiles();
    
    for (const file of files) {
      this.results.totalFiles++;
      const content = fs.readFileSync(file, 'utf8');
      
      // Buscar Math.random()
      const mathRandomMatches = this.findMathRandomUsages(content, file);
      
      if (mathRandomMatches.length > 0) {
        this.results.mathRandomUsages.push({
          file: this.getRelativePath(file),
          matches: mathRandomMatches
        });
      } else {
        this.results.verifiedFiles++;
      }
    }
    
    if (this.results.mathRandomUsages.length === 0) {
      console.log('  ‚úÖ No se encontraron usos de Math.random() en el c√≥digo fuente');
    } else {
      console.log(`  ‚ö†Ô∏è  Se encontraron ${this.results.mathRandomUsages.length} archivos con Math.random()`);
    }
  }

  /**
   * Encuentra usos de Math.random() en el contenido
   */
  findMathRandomUsages(content, filePath) {
    const lines = content.split('\n');
    const matches = [];
    
    lines.forEach((line, index) => {
      if (line.includes('Math.random()')) {
        // Verificar si es un uso leg√≠timo (comentarios, fallbacks, etc.)
        const isComment = line.trim().startsWith('//') || line.trim().startsWith('*');
        const isFallback = line.includes('fallback') || line.includes('Fallback');
        const isDocumentation = line.includes('reemplaza') || line.includes('sistema');
        
        const usage = {
          lineNumber: index + 1,
          content: line.trim(),
          isLegitimate: isComment || isFallback || isDocumentation
        };
        
        matches.push(usage);
      }
    });
    
    return matches;
  }

  /**
   * Verifica las implementaciones del sistema cu√°ntico
   */
  async verifyQuantumImplementations() {
    console.log('\n‚öõÔ∏è  Verificando implementaciones del sistema cu√°ntico...');
    
    const quantumFiles = [
      'lib/utils/quantumRandom.ts',
      'lib/services/examGeneratorService.ts',
      'lib/services/examSessionService.ts',
      'lib/services/recommendationService.ts',
      'lib/services/userDataService.ts',
      'fuentes/bloom-skill-flow-main/src/bloom-assessment/ProgressiveAssessment.ts'
    ];
    
    for (const file of quantumFiles) {
      const filePath = path.join(PROJECT_ROOT, file);
      
      if (fs.existsSync(filePath)) {
        const content = fs.readFileSync(filePath, 'utf8');
        const implementation = this.analyzeQuantumImplementation(content, file);
        
        this.results.quantumImplementations.push(implementation);
        
        if (implementation.hasQuantumImport && implementation.hasQuantumUsage) {
          console.log(`  ‚úÖ ${file} - Sistema cu√°ntico implementado`);
        } else if (implementation.analyzed) {
          console.log(`  ‚ö†Ô∏è  ${file} - Implementaci√≥n incompleta`);
        } else {
          console.log(`  ‚ÑπÔ∏è  ${file} - No requiere sistema cu√°ntico`);
        }
      } else {
        console.log(`  ‚ùå ${file} - Archivo no encontrado`);
      }
    }
  }

  /**
   * Analiza la implementaci√≥n del sistema cu√°ntico en un archivo
   */
  analyzeQuantumImplementation(content, file) {
    const hasQuantumImport = content.includes('quantumRandom') || content.includes('generate_quantum_number');
    const hasQuantumUsage = content.includes('quantumRandom()') || content.includes('quantumRandomSync()') || content.includes('supabase.rpc(\'generate_quantum_number\')');
    const hasMathRandom = content.includes('Math.random()');
    const analyzed = hasQuantumImport || hasQuantumUsage || hasMathRandom;
    
    return {
      file,
      hasQuantumImport,
      hasQuantumUsage,
      hasMathRandom,
      analyzed,
      isComplete: hasQuantumImport && hasQuantumUsage && !hasMathRandom
    };
  }

  /**
   * Verifica la configuraci√≥n del sistema
   */
  async verifySystemConfiguration() {
    console.log('\n‚öôÔ∏è  Verificando configuraci√≥n del sistema...');
    
    // Verificar endpoint de estado
    const quantumStatusPath = path.join(PROJECT_ROOT, 'app/api/quantum-status/route.ts');
    if (fs.existsSync(quantumStatusPath)) {
      console.log('  ‚úÖ Endpoint de estado cu√°ntico configurado');
    } else {
      this.results.issues.push({
        type: 'missing_endpoint',
        message: 'Endpoint de estado cu√°ntico no encontrado'
      });
    }
    
    // Verificar funci√≥n RPC en Supabase (nota: no podemos verificar la DB directamente)
    console.log('  ‚ÑπÔ∏è  Verificar manualmente que la funci√≥n RPC "generate_quantum_number" est√© configurada en Supabase');
    
    // Verificar documentaci√≥n
    const docsPath = path.join(PROJECT_ROOT, 'docs/quantum-random-system.md');
    if (fs.existsSync(docsPath)) {
      console.log('  ‚úÖ Documentaci√≥n del sistema cu√°ntico disponible');
    } else {
      console.log('  ‚ö†Ô∏è  Documentaci√≥n del sistema cu√°ntico no encontrada');
    }
  }

  /**
   * Obtiene todos los archivos fuente a verificar
   */
  getSourceFiles() {
    const files = [];
    
    for (const dir of CONFIG.includeDirs) {
      const dirPath = path.join(PROJECT_ROOT, dir);
      if (fs.existsSync(dirPath)) {
        const dirFiles = this.scanDirectory(dirPath);
        files.push(...dirFiles);
      }
    }
    
    return files.filter(file => {
      // Filtrar por extensi√≥n
      const hasValidExtension = CONFIG.fileExtensions.some(ext => file.endsWith(ext));
      
      // Excluir archivos espec√≠ficos
      const isExcludedFile = CONFIG.excludeFiles.some(excluded => file.includes(excluded));
      
      // Excluir directorios
      const isInExcludedDir = CONFIG.excludeDirs.some(excluded => file.includes(excluded));
      
      return hasValidExtension && !isExcludedFile && !isInExcludedDir;
    });
  }

  /**
   * Escanea recursivamente un directorio
   */
  scanDirectory(dirPath) {
    const files = [];
    
    try {
      const entries = fs.readdirSync(dirPath);
      
      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          // Recursivo para subdirectorios
          if (!CONFIG.excludeDirs.some(excluded => entry.includes(excluded))) {
            files.push(...this.scanDirectory(fullPath));
          }
        } else if (stat.isFile()) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      console.warn(`Advertencia: No se pudo escanear directorio ${dirPath}`);
    }
    
    return files;
  }

  /**
   * Obtiene la ruta relativa al proyecto
   */
  getRelativePath(filePath) {
    return path.relative(PROJECT_ROOT, filePath);
  }

  /**
   * Genera el reporte final
   */
  generateReport() {
    console.log('\n' + '='.repeat(80));
    console.log('üìä REPORTE DE VERIFICACI√ìN DEL SISTEMA CU√ÅNTICO');
    console.log('='.repeat(80));
    
    // Resumen general
    console.log('\nüìà RESUMEN GENERAL:');
    console.log(`  ‚Ä¢ Archivos verificados: ${this.results.verifiedFiles}/${this.results.totalFiles}`);
    console.log(`  ‚Ä¢ Implementaciones cu√°nticas: ${this.results.quantumImplementations.filter(impl => impl.isComplete).length}`);
    console.log(`  ‚Ä¢ Usos restantes de Math.random(): ${this.results.mathRandomUsages.length}`);
    console.log(`  ‚Ä¢ Problemas encontrados: ${this.results.issues.length}`);
    
    // Usos restantes de Math.random()
    if (this.results.mathRandomUsages.length > 0) {
      console.log('\n‚ö†Ô∏è  USOS RESTANTES DE Math.random():');
      this.results.mathRandomUsages.forEach(usage => {
        console.log(`\n  üìÑ ${usage.file}:`);
        usage.matches.forEach(match => {
          const status = match.isLegitimate ? '‚úÖ' : '‚ùå';
          console.log(`    ${status} L√≠nea ${match.lineNumber}: ${match.content}`);
        });
      });
    }
    
    // Estado de implementaciones
    console.log('\n‚öõÔ∏è  ESTADO DE IMPLEMENTACIONES:');
    this.results.quantumImplementations.forEach(impl => {
      if (impl.analyzed) {
        const status = impl.isComplete ? '‚úÖ' : '‚ö†Ô∏è ';
        console.log(`  ${status} ${impl.file}`);
        if (!impl.isComplete) {
          if (!impl.hasQuantumImport) console.log(`      - Falta importar sistema cu√°ntico`);
          if (!impl.hasQuantumUsage) console.log(`      - Falta usar funciones cu√°nticas`);
          if (impl.hasMathRandom) console.log(`      - Todav√≠a usa Math.random()`);
        }
      }
    });
    
    // Problemas encontrados
    if (this.results.issues.length > 0) {
      console.log('\n‚ùå PROBLEMAS ENCONTRADOS:');
      this.results.issues.forEach((issue, index) => {
        console.log(`  ${index + 1}. ${issue.type}: ${issue.message}`);
        if (issue.file) console.log(`     Archivo: ${issue.file}`);
      });
    }
    
    // Conclusi√≥n
    const isFullyUnified = this.results.mathRandomUsages.every(usage => 
      usage.matches.every(match => match.isLegitimate)
    ) && this.results.issues.length === 0;
    
    console.log('\n' + '='.repeat(80));
    if (isFullyUnified) {
      console.log('üéâ ¬°UNIFICACI√ìN COMPLETA! El sistema cu√°ntico ha sido implementado exitosamente.');
      console.log('   Todos los usos de Math.random() han sido reemplazados o son leg√≠timos (comentarios/fallbacks).');
    } else {
      console.log('üîß UNIFICACI√ìN INCOMPLETA. Revisar los problemas encontrados arriba.');
    }
    console.log('='.repeat(80));
    
    // Recomendaciones
    console.log('\nüí° RECOMENDACIONES:');
    console.log('  1. Verificar manualmente la funci√≥n RPC "generate_quantum_number" en Supabase');
    console.log('  2. Probar el endpoint GET /api/quantum-status para verificar el estado del sistema');
    console.log('  3. Ejecutar pruebas de los servicios que usan n√∫meros aleatorios');
    console.log('  4. Monitorear el rendimiento del sistema cu√°ntico en producci√≥n');
    
    return isFullyUnified;
  }
}

// Ejecutar verificaci√≥n si se llama directamente
if (require.main === module) {
  const verifier = new QuantumUnificationVerifier();
  verifier.verify().then(() => {
    console.log('\n‚ú® Verificaci√≥n completada.');
    process.exit(0);
  }).catch(error => {
    console.error('\nüí• Error en la verificaci√≥n:', error);
    process.exit(1);
  });
}

module.exports = { QuantumUnificationVerifier };
